---
title: "End Joining Signatures"
author: "Charlie Soeder"
date: "4/4/2019"
output:
  pdf_document:
    toc: true
    toc_depth: 5
    number_sections: true
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_knit$set(root.dir = '/Users/csoeder/Research/PSIseq/EJgrepper/')
#knitr::opts_knit$set(root.dir = '/proj/cdjones_lab/csoeder/EJgrepper/')
knitr::opts_knit$set(root.dir=peaDubDee)

library("yaml")
library("readr")
library("knitr")
library("ggbio")
library("VennDiagram")
library("tidyverse")
library("broom")
```


```{r include=FALSE}

human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}



multicolumn_ACloader <- function(filename){
	
	max_fields<- count.fields(filename, sep = '\t') %>% max()

	tubb <- read.table(filename, header = FALSE, sep = "\t", fill = TRUE,col.names = paste0("V",seq_len(max_fields)))

	tubb.df <- tubb[1:7]

	names(tubb.df) <- c("site_id", "chrom", "pos", "var_count", "chroms_avail", "allele", "allele_count")
	tubb.df$var_num <- 1
	
	for (i in seq(8,max_fields,2)){
		tubb.df.tmp <- cbind(tubb[1:5], tubb[c(i,i+1)])
		names(tubb.df.tmp) <- c("site_id", "chrom", "pos", "var_count", "chroms_avail", "allele", "allele_count")
		tubb.df.tmp$var_num <- i/2-2
		tubb.df <- rbind(tubb.df, tubb.df.tmp %>% filter(!is.na(allele_count))  )
	}

	tubb.df <- tubb.df %>% mutate(allele_freq = allele_count/chroms_avail) %>% as_tibble()

	
	
		return( tubb.df)
}


```

# Introduction

[@McVey2008]
[@Miller2016]


# Materials, Methods, Data, Software

```{r include=FALSE}

trammel <- read_yaml("config.yaml")

```

High-thoughoutput sequences in FASTQ format were aligned to the reference genome using BWA[@Li2009] and processed with SAMtools [@Li2009a] and BEDtools [@Quinlan2010]. Variants were called from these alignments using Freebayes [@Garrison2012] and processed using VCFTools[@Danecek2011]. 


## Reference Genomes


```{r include=FALSE}
refGenomes_summary_df <- read_delim("meta/reference_genomes.summary", 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE)

names(refGenomes_summary_df) <- c("refGenome","measure","value")

```

The dm6 reference genome was used for read alignment:
```{r echo=FALSE}

refGenomes_summary_df %>% mutate( value=human_readable_croncher(value)) %>% spread(refGenome, value) %>% rename('Reference Genome:'=measure)  %>% kable(caption="Size and Consolidation of Reference Genomes")

```


## Sequenced Reads
```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$paired<- as.factor(data_sets.df$paired)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$subgroups<- as.factor(data_sets.df$subgroups)
data_sets.df$pedigree<- as.factor(data_sets.df$pedigree)
data_sets.df$sex<- as.factor(data_sets.df$sex)

data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,sra)) %>% distinct() 

```

Two treatments have been sequenced: a control line, and an mcm5 mutant. The data available include two parent flies per treatment as well as 28 of their male offspring: 

```{r echo=FALSE, results='asis'}
data_sets.df.sparse %>% group_by(experimental,pedigree) %>% summarise(sample_count=n()) %>% kable(caption="Number of Sequenced Samples by Treatment")
```

The samples from the mcm5 mutant cross were provided by Talia. These include two "parents" (w1118 and Iso1), which provided chromosomes 2, 4, X, and Y. From these, a fly ("A7") was engineered with a w1118 background and [details about A7 chr3 here]. Another ("Df") was engineered with an mcm5 deficiency on chromosome 3. These were mated and a female F1 selected, having a genome which is w1118/Iso1 except for chromosome 3, which is A7/Df. This F1 female was then mated with an Iso1 male, and the male F2 offspring collected and sequenced. These F2 are thus expected to have ancestry of ~3:1 Iso1:w1118 on chromosomes 2 and 4, ~1:1 on chromosome X, and a chromosome Y which is solely Iso1. The A7 and Df flies have also been sequenced, and this data may be integrated later to reconstruct chromosome 3. 


```{r echo=FALSE}
data_sets.df.sparse %>% filter(experimental == 'mutant') %>% select(c(name, source, pedigree, sex)) %>%  arrange(pedigree, desc(name)) %>% kable(caption="Sequenced Samples from mcm5 Mutant Cross")
```

The control samples were first published in [@Miller2016]; this cross consists of a male w1118 and a female Canton S, as well as their male offspring. 28 of the 196 sequenced offspring were selected at random and downloaded from NCBI, as were the sequenced parents:

>Males were numbered based on whether their father was homozygous w1118 or Canton-S and the number of their het- erozygous mother. For example, male cs12.3 had a Canton-S father, its mother was female number 12, and it was the third male selected for DNA extraction.

```{r echo=FALSE, warning=FALSE}


data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,sra)) %>% distinct() 

data_sets.df.sparse.crossMeta <- data_sets.df.sparse %>% filter(experimental == 'control') %>% select(c(name, source, pedigree, sex))  %>% mutate(tmp=name) %>% separate(tmp, sep="_", into = c("mating","offspring_id"))  %>% mutate(tmp=mating) %>% separate(tmp, sep="[sw]", into=c("A","B"))%>% mutate(tmp=mating) %>% separate(tmp, sep="[0-9]", into=c("A","C")) %>% mutate(mating=case_when(pedigree=='child' ~ mating), father_type=case_when(pedigree=='child' ~ A), mother_id=case_when(pedigree=='child' ~ B) ) %>% select(-c(A,B,C)) %>% mutate(father_type=case_when(father_type=='w' ~ "w1118",father_type=='cs' ~ "CantonS") ) 


```

```{r echo=FALSE}


data_sets.df.sparse.crossMeta %>% select(-c(mating))%>% arrange(pedigree, desc(name)) %>% kable(caption="Sequenced Samples from Control Cross")
```


```{r echo=FALSE}

data_sets.df.sparse.crossMeta %>% filter(pedigree=='child') %>% group_by(father_type, mother_id) %>% summarize(count=n()) %>% kable(caption="Number of Male Offsping Sequenced, by Cross Type and Female ID")

```


### Pre-Processing

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics. 


```{r echo=FALSE, include=FALSE}
fastp_summary <- read_delim("meta/sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```




```{r echo=FALSE, include=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df.sparse, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```


Starting FASTQ files contained a total of  $`r sum( filtration_stats %>% filter(type =='prefiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$. 



```{r echo=FALSE}
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE}
rbind(pre_post_counts, retention_percent) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average) , maximum = human_readable_croncher(maximum)) %>% kable(caption="Read Count and Percent Retention")
```

Filtration also increased the read quality, as seen in the increase in the fraction of reads with an average quality score > 30:

```{r echo=FALSE}
ggplot(filtration_stats %>% filter(measure == "q30_rate")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental)) + labs(title = "Percent of Reads with a mean QUAL > 30", y="Percent QUAL > 30", x="") + theme_clear()

```



Duplicate reads were also detected; these will be filtered during alignment:

```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df.sparse, by=c("name"="name"))
```

```{r echo=FALSE}
dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% kable(caption="Percentage Duplication",digits=1)
```

```{r echo=FALSE}
ggplot(dupe_stats) + geom_histogram(aes(x=percent), bins=15) + labs(title="Duplication Histogram", x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + theme_clear()
```



## Mapped Reads

Reads were first mapped to the reference genome using the BWA SAMPE/SE algorithm. Then, the alignment file was filtered for uniqueness (ie, a read must be aligned optimally with no alternative or runner-up hits, "XT:A:U.*X0:i:1.*X1:i:0"), mapping/sequencing quality ("-q 20 -F 0x0100 -F 0x0200 -F 0x0300 -F 0x04"), and deduplication. 



```{r echo=FALSE, include=FALSE}

vs_dm6.bwa <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")
vs_dm6.bwaUniq <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")

all_alignments <- rbind(vs_dm6.bwa, vs_dm6.bwaUniq)
```



### Read & Alignment Quality



```{r echo=FALSE, warning=FALSE}
readcount_process <- all_alignments %>%  filter( (measure=='total_read_count' & aligner=="bwa") | measure == 'total_mapped_count' ) %>% mutate(measure=ifelse(aligner=="bwaUniq", "filtered_mapped_count", ifelse(measure=="total_read_count","total_read_count","total_mapped_count"))) 
readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count','filtered_mapped_count'))
```

The fraction of reads retained at each filtration step:


```{r echo=FALSE, warning=FALSE}
#ggplot(readcount_process) +
ggplot(inner_join(readcount_process, data_sets.df.sparse, by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=experimental, shape=pedigree))  + labs(title="Read Counts by Processing Step: Unmapped, Mapped, Filtered", x="", y="Number Reads" ) + theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0), legend.position='none' ) 

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>% select(-c(aligner)) %>%  spread(measure, value) %>%  mutate(mapping_retention=total_mapped_count/total_read_count, filter_retention = filtered_mapped_count/total_mapped_count)



readcount_process.spread.gathered <- readcount_process.spread%>% gather(total_read_count:filtered_mapped_count, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average), median = human_readable_croncher(median), maximum = human_readable_croncher(maximum))

#readcount_process.spread.gathered$measure <- factor(readcount_process.spread.gathered$measure, levels=c("total_read_count", "total_mapped_count","filtered_mapped_count"))

readcount_process.spread.gathered %>% kable(caption="Read Counts During Alignment & Filtration")

```


```{r echo=FALSE}
readcount_process.spread %>% gather(mapping_retention:filter_retention, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(100*value), average=mean(100*value), median = median(100*value), maximum = max(100*value)) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average), median = human_readable_croncher(median), maximum = human_readable_croncher(maximum)) %>%  kable(caption="Percentage of Reads Retained at Each Step",digits=1)

```



### Depth & Breadth of Coverage


```{r echo=FALSE, include=FALSE}

before_After.cov <- inner_join( vs_dm6.bwa %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), vs_dm6.bwaUniq %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), by='sample', suffix=c(".before",".after") ) %>%  mutate(depth_retention = avg_depth.after/avg_depth.before, breadth_retention=total_breadth.after/total_breadth.before)


before_After.cov.gathered.meta <- inner_join(before_After.cov %>%  gather(avg_depth.before:breadth_retention, key="measure", value="value") , data_sets.df.sparse, by=c("sample"="name") ) 


```


Depth of coverage, ie, the genome-wide average number of mapped reads per base pair:


```{r echo=FALSE}

depth.process <- all_alignments  %>%  filter(measure=='avg_depth' )%>% spread(aligner, value) %>%  mutate(depth_retention = 100*bwaUniq/bwa) %>% rename( "before" = bwa,  "after" = bwaUniq)

covstats.dpth <- depth.process %>% summarise(step="pre-filtration depth",minimum = min(before), average=mean(before), median = median(before), maximum = max(before))

covstats.dpth <- rbind(covstats.dpth, depth.process %>% summarise(step="post-filtration depth",minimum = min(after), average=mean(after), median = median(after), maximum = max(after)))

covstats.dpth <- rbind(covstats.dpth, depth.process  %>% summarise(step="depth retention percent",minimum = min(depth_retention), average=mean(depth_retention), median = median(depth_retention), maximum = max(depth_retention)))

covstats.dpth %>% kable(caption="Depth of Coverage Statistics for Raw and Filtered Alignments", digits=1 )
```


```{r echo=FALSE, warning=FALSE}
depth.process <- inner_join(depth.process, data_sets.df.sparse %>% select(-c("paired", "path", "readsfile1", "readsfile2")), by=c("sample"="name"))

ggplot(depth.process %>%  select(-c(depth_retention,measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after"))))  +geom_line(aes(group=sample, x=measure,y=value))+ geom_point(aes(group=sample, x=measure,y=value, shape=experimental, color=pedigree)) + geom_text(data=depth.process %>%  select(-c(depth_retention,measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after"))) %>% filter(value < 25), aes(as.factor("after"),value,label=sample)) + theme_clear()   +  labs(title="Depth Of Coverage for Raw and Filtered Alignments", x="", y="Reads Per BP, Genome-Wide" ) 

```


```{r echo=FALSE, include=FALSE}
breadth.process <- all_alignments %>%  filter(measure=='total_breadth' ) %>% spread(aligner, value) %>%  mutate(breadth_retention = 100*bwaUniq/bwa) %>% rename( "before" = bwa, "after" = bwaUniq)

covstats.brdth <- breadth.process %>% summarise(step="pre-filtration breadth",minimum = 100*min(before), average=100*mean(before), median = 100*median(before), maximum = 100*max(before))

covstats.brdth <- rbind(covstats.brdth, breadth.process %>% summarise(step="post-filtration breadth",minimum = 100*min(after), average=100*mean(after), median = 100*median(after), maximum = 100*max(after)))

covstats.brdth <- rbind(covstats.brdth, breadth.process  %>% summarise(step="breadth retention percent",minimum = min(breadth_retention), average=mean(breadth_retention), median = median(breadth_retention), maximum = max(breadth_retention)))

covstats.brdth %>% kable(caption="Breadth of Coverage Statistics for Raw and Filtered Alignments", digits=1 )

```


Breadth of coverage, ie, the percentage of the genome covered by at least one read:

```{r echo=FALSE, warning=FALSE}

breadth.process <- inner_join(breadth.process, data_sets.df.sparse %>% select(-c("paired", "path", "readsfile1", "readsfile2")), by=c("sample"="name"))



ggplot(breadth.process %>%  select(-c(breadth_retention, measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after")), value=100*value) ) + geom_point(aes(group=sample, x=measure,y=value, shape=experimental, color=pedigree)) + geom_line(aes(group=sample, x=measure,y=value)) + theme_clear()  + labs(title="Breadth Of Coverage for Raw and Filtered Alignments", x="", y="Percentage of Reference Genome Mapped To" )
#  + geom_text(data=breadth.process %>%  select(-c(breadth_retention, measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after")), value=100*value), aes(as.factor("after"),value,label=sample, x=)) 
```


## Called Variants

The BWA-Uniq alignments for the control and mutant flies were independently used to call variants in VCF format via Freebayes [@Garrison2012] using standard filters, and providing sex chromosome ploidy for each individual fly. 


```{r echo=FALSE, warning=FALSE, message=FALSE}

allGroups.vs_dm6.calledVariants.summary <- read_delim("meta/allGroups.vs_dm6.bwaUniq.calledVariants.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(allGroups.vs_dm6.calledVariants.summary) <- c("group", "aligner", "variant_type", "count")
allGroups.vs_dm6.calledVariants.summary$aligner <- as.factor(allGroups.vs_dm6.calledVariants.summary$aligner)
allGroups.vs_dm6.calledVariants.summary$variant_type <- as.factor(allGroups.vs_dm6.calledVariants.summary$variant_type)

reference_genomes_summaryStats.sprud <- refGenomes_summary_df %>%  spread(measure,value) %>%  select(c(-number_contigs)) 

allGroups.vs_dm6.calledVariants.summary.sprud <- allGroups.vs_dm6.calledVariants.summary %>% spread(variant_type, count) %>%  transmute( aligner=aligner, group = group, INDELs = total_indel_count, SNPs = total_snp_count) 

allGroups.vs_dm6.calledVariants.summary.sprud$total_bp <- reference_genomes_summaryStats.sprud$number_bases


allGroups.vs_dm6.calledVariants.summary.sprud %>%  transmute( aligner=aligner, INDELs = INDELs, INDEL_per_kb=1000*INDELs/total_bp, SNPs = SNPs, SNP_per_kb=1000*SNPs/total_bp) %>% mutate(INDELs=human_readable_croncher(SNPs), INDELs=human_readable_croncher(SNPs) ) %>%  kable(caption="Variant Counts and Frequency by Type and Group", digits=1 )
```


For each group VCF, 30 samples from the group called jointly. However, not all sites were called in all samples (eg, due to coverage differences). The sites had the following group-wide call rate:


```{r echo=FALSE, include=FALSE}
mutant.calledVariants.bwaUniq.lmiss <- read_delim("meta/VCFs/mutant.vs_dm6.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
mutant.calledVariants.bwaUniq.lmiss$group <- "mutant"

control.calledVariants.bwaUniq.lmiss <- read_delim("meta/VCFs/control.vs_dm6.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
control.calledVariants.bwaUniq.lmiss$group <- "control"

allGroups.calledVariants.lmiss <- rbind(control.calledVariants.bwaUniq.lmiss, mutant.calledVariants.bwaUniq.lmiss) #%>% select(c(group, N_MISS, N_DATA)) %>%  mutate(group=as.factor(group), N_PRES=floor(N_DATA/2))

```



```{r echo=FALSE, warning=FALSE}

#nsamps <- max(allGroups.calledVariants.lmiss$N_PRES)

#ggplot(allGroups.calledVariants.lmiss) + geom_freqpoly(aes(x=N_PRES, group=group, color=group), bins=nsamps) + scale_x_continuous(name ="Number Samples",limits=c(1,nsamps), breaks =seq(1,nsamps,1)) + theme_clear() + labs(title="Histogram of Variant Site Count,\n by Number of Samples Called At Site", y="Number of Sites")

ggplot(allGroups.calledVariants.lmiss) + geom_freqpoly(aes(x=1-F_MISS, group=group, color=group), bins=20) + scale_x_continuous(name ="Fraction of Samples",limits=c(0,1), breaks =seq(0,1,0.1)) + theme_clear() + labs(title="Histogram of Variant Site Count,\n by Number of Samples Called At Site", y="Number of Sites")


```


The fraction of jointly called SNPs which are individually callable:

```{r echo=FALSE, include=FALSE}


mutant.calledVariants.imiss <- read_delim("meta/VCFs/mutant.vs_dm6.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
mutant.calledVariants.imiss$group <- "mutant"

control.calledVariants.imiss <- read_delim("meta/VCFs/control.vs_dm6.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
control.calledVariants.imiss$group <- "control"


allGroups.calledVariants.imiss <- rbind(control.calledVariants.imiss, mutant.calledVariants.imiss)  %>%  mutate(name=as.factor(INDV), group=as.factor(group), N_PRES=N_DATA-N_MISS) %>% select(c( name, N_MISS, N_PRES, F_MISS,group))

```

```{r echo=FALSE, include=FALSE}


allGroups.imiss.augmented <- inner_join(allGroups.calledVariants.imiss, all_alignments %>%  filter(measure=='total_breadth') %>% filter(aligner=="bwaUniq") %>% select(c(sample,value)) %>% rename(breadth=value) %>% mutate(breadth = 100*breadth), by=c("name"="sample"))

allGroups.imiss.augmented <-inner_join(allGroups.imiss.augmented, all_alignments %>%  filter(measure=='avg_depth') %>% filter(aligner=="bwaUniq") %>% select(c(sample,value)) %>% rename(depth=value), by=c("name"="sample"))

allGroups.imiss.augmented <- allGroups.imiss.augmented %>%  gather(breadth:depth, key="measure", value="value")

```

```{r echo=FALSE}
ggplot(allGroups.imiss.augmented) + geom_point(aes(x= value, y=1-F_MISS, color=group, shape=group)) + facet_grid(.~measure, scales="free_x") + theme_clear() + labs(x="", y="Fraction of Sites Callable", title="Jointly Called Variants Callable per Sample,\n by Breadth and Depth of Coverage")


```

## Variant Analysis

```{r echo=FALSE, warning=FALSE}

filteredTbl.cntrl <- multicolumn_ACloader("analysis/control.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.out") 
filteredTbl.cntrl$group <- as.factor("control")

filteredTbl.mut <- multicolumn_ACloader("analysis/mutant.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.out") 
filteredTbl.mut$group <- as.factor("mutant")

#filteredTbl.biallele <- rbind(filteredTbl.cntrl, filteredTbl.mut) %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) 

filteredTbl.biallele <- rbind(filteredTbl.cntrl  %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) , filteredTbl.mut %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`))  )


filteredTbl.biallele.tmp <- filteredTbl.biallele %>% filter(`1_allele_count` >= `2_allele_count`) %>% mutate(delta_bp=len2-len1,  mac=`2_allele_count`)

filteredTbl.biallele <- rbind(filteredTbl.biallele.tmp, filteredTbl.biallele %>% filter(`1_allele_count` < `2_allele_count`) %>% mutate(delta_bp=len1-len2, mac=`1_allele_count`)) %>% mutate( group=`1_group`) %>%  select(-c(`2_group`))
```

To search for traces of end-joining, the BWA-Uniq derived variants were further filtered, requiring a depth of 10 reads at the site for all flies sequenced: the per-site probability of sampling the same chromosome 10 times is < 0.1% given a fair draw, but this threshold is lower than the minimum average depth of coverage among the samples. Although it is possible that the join could occur near an already polymorphic site, or might manifest as a complex variant rather than a simple insertion/deletion, for the time being only proper biallelic indels were retained. Only sites which could be called in all 30 sequenced flies were considered. 


Between the two treatments, this gave a total of $`r filteredTbl.biallele %>% nrow()  `$ sites: 

```{r echo=FALSE}
filteredTbl.biallele.tot <- rbind(filteredTbl.biallele %>% group_by(chrom,group) %>% summarize(count=n()) %>% spread(group,count) %>% ungroup(), filteredTbl.biallele %>% group_by(group) %>% summarize(count=n()) %>% spread(group,count) %>% mutate(chrom=as.character("total")) %>% select(c("chrom","mutant","control")))


filteredTbl.biallele.tot %>%  kable(caption="Quality Biallaeleic INDELs per Chromosome")
```

For these sites, minor and major alleles were assigned on the basis of which of the two variants had a smaller or larger allele count, respectively. INDEL type & size were determined relative to the major allele. To test for mutational bias, R's built in proportion test was applied to the number of deletions compared to the total number of INDELs, with a null hypothese of 0.5 (ie, deletions are as likely as insertions).

### Novel Variant Identification

Double-strand breaks introduce new variants in the offspring which were not present in the parent flies. The VCFs were thus filtered to collect sites which have an allele in at least one offspring which was not detected in either parent. This can happen two ways: both parents may be homozygous for the reference, with an alternate allele sighted in the offspring, or both parents may be homozygous for an alternate allele, with the reference sighted in the offspring. These two cases have different connotations and were split in two with each case examined separately, with different results (see 3.1.2 below).




# Results

## INDEL Size & Frequency


```{r echo=FALSE}
ggplot(filteredTbl.biallele %>%  group_by(mac, delta_bp,group) %>% summarise(count=n())) + geom_tile(aes(x=mac,y=delta_bp, fill=count)) +facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Nucleotides Inserted or Deleted", title="Heatmap of INDEL Count, by Frequency and Size") + scale_fill_gradient(name = "Site Count", trans = "log", breaks = c(1,10,100,1000), labels = c(1,10,100,1000)) + theme( panel.background = element_rect(fill = "black", colour = "black"))
```


Since DSB is likely to create unique variants in the population, allele frequency is an important property to filter on. To get an idea of the expected allele frequency distribution, consider that for a given variable site, a diploid parent may be homozygous reference (a/a), homozygous alternate (A/A), or heterozygous (a/A). Thus, there are five relevant pairings of genotype: AA x AA, aa x aA, aa x AA, aA x AA, and aA x aA. Under random assortment, the aa x aA and aA x AA crosses give a minor allele frequency of 1/4 and the aa x AA and aA x aA crosses give a minor allele frequency of 1/2. Finally, the AA x AA cross corresponds to the case where the parents are fixed for an alternate allele, and  aa x aa corresponds to the case in which both parents are fixed for the reference allele; in both cases the offpsring would be expected to be fixed as well and the minor allele frequency would thus be zero. So, given sample of 30 diploid flies, the expected distribution of minor allele counts would be peaks centered on 0, 15, and 30. (The haploid X chromosome would be expected to have peaks at 0 and ~7.5)



```{r echo=FALSE}
ggplot(filteredTbl.biallele) + geom_freqpoly(aes(x=mac),bins=15, color='black') + geom_freqpoly(aes(x=mac, color=chrom),bins=31) + facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Number of Sites", title="Number of Quality INDELs, by Minor Allele Count, Chromosome, and Treatment")
#mac0 <-filteredTbl.biallele %>% filter(mac == 0) %>% nrow() 
#mac1 <-filteredTbl.biallele %>% filter(mac == 1) %>% nrow() 
#mac2 <-filteredTbl.biallele %>% filter(mac == 2) %>% nrow() 
#macTot <- filteredTbl.biallele %>%  nrow()
#rareRefs <- filteredTbl.biallele %>%  filter(`1_allele_count`<3) %>% filter(`1_allele_count`>0) %>% group_by(mac) %>% summarize(count=n()) %>% select(count) %>% sum()
```

Both the control and mutant flies have peaks near 0, but on closer inspection these appear to be different phenomena. Whereas the control flies contain many sites with a minor allele count of zero (corresponding to fixed differences with the reference), the mutant flies had very few. The near-zero peak in the mutants consists of sites with one or two of the 60 chromosomes carrying the rarer allele:

```{r echo=FALSE}
filteredTbl.biallele %>% filter(mac<4) %>% group_by(group, mac) %>%  summarize(count=n()) %>% spread(group,count) %>% kable(caption = "Low-Frequency Site Details for Controls and Mutants")
```

Both samples have slightly skewed but generally reasonable peaks in the 10-20 count range, corresponding to alleles with frequency ~25%. The control flies are depleted of alleles with a count near 30 (frequency ~50%), but the mutants are not. However, the mutants' variants in this range almost all on the arms of chromosome 3; conversely, almost all of their very rare variants are on the arms of chromosome 3 (which is not currently informative) or on chromosome X. ( _did we decide that this is because 2 is isogenized and 3 isn't?_)


```{r echo=FALSE}
ggplot(filteredTbl.biallele) + geom_freqpoly(aes(x=mac, color=group),bins=31) + facet_wrap(chrom~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Number of Sites", title="Number of Quality INDELs, by Minor Allele Count, Treatment, and Chromosome")
```

Another unusual feature of both groups is that mid-range variants (frequency ~25%) do not appear to be unimodes centered at MAC=15, but rather split into smaller peaks near MAC~10 and MAC~20. These would correspond to ratios of ~1/6 and 2/6. 


```{r echo=FALSE}
ggplot(filteredTbl.biallele)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=13)  + theme_clear() + labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size")
```


INDEL size ranged from 6bp deletions to 6bp insertions, with a small but significant bias towards deletion:


```{r echo=FALSE}
insert_truth.Tbl <- filteredTbl.biallele %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)
insert_truth.Tbl <- cbind(insert_truth.Tbl, map2(insert_truth.Tbl$del, insert_truth.Tbl$del+insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )
 
kable(insert_truth.Tbl, caption = "Deletion Bias in mcm5 Mutants vs. Controls")

```

(A similar result holds if the count by type is scaled by the change in length, for a ratio of total bp removed to total bp change).

When constrained to a single MAC value, the degree of mutational bias varies, within and between the two treatments. 


```{r echo=FALSE,warning=FALSE}

ggplot(filteredTbl.biallele %>% mutate(ins=delta_bp>0) %>% group_by(mac,ins,group) %>% summarise(count=n()) %>% spread(ins,count) %>% rename(ins=`TRUE`, del=`FALSE`) %>%  mutate(rat = prop.test(del, ins+del)$estimate, pea=prop.test(del, ins+del)$p.value, peaAdj = p.adjust(pea, method='bonferroni'))) + geom_line(aes(x=mac, y=rat, linetype=group), alpha=0.25) + geom_point(aes(x=mac, y=rat, color=group, alpha=peaAdj<0.05)) + geom_hline(yintercept=0.5, linetype='dotted', color='blue', size=1) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Proportion of Deletions", title="Results of Proportion Test for Deletions, by Minor Allele Count", alpha = "significance\n(adjusted)")

```


### Novel INDELs (forward mutation)

```{r echo=FALSE, warning=FALSE}
control.novel.counts <- multicolumn_ACloader("analysis/control.vs_dm6.bwaUniq.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.novel.count")
control.novel.counts$group <- as.factor("control")

mutant.novel.counts <- multicolumn_ACloader("analysis/mutant.vs_dm6.bwaUniq.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.novel.count")
mutant.novel.counts$group <- as.factor("mutant")

#biallele.novel.counts <- rbind(control.novel.counts, mutant.novel.counts) %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) 

biallele.novel.counts <- rbind(control.novel.counts %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)), mutant.novel.counts%>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)))  


biallele.novel.counts.tmp <- biallele.novel.counts %>% filter(`1_allele_count` >= `2_allele_count`) %>% mutate(delta_bp=len2-len1,  mac=`2_allele_count`)

biallele.novel.counts <- rbind(biallele.novel.counts.tmp, biallele.novel.counts %>% filter(`1_allele_count` < `2_allele_count`) %>% mutate(delta_bp=len1-len2, mac=`1_allele_count`)) %>% mutate( group=`1_group`) %>%  select(-c(`2_group`))

```

These sites were further filtered to collect those which are heredetarily novel, which is to say, non-reference alleles which appear in at least one offspring but neither parent. These are comparable in number between in the mutant flies and the controls, except on chromosome 3, where spurious novelty is introduced by the w1118/Iso1 background standing in for the true A7/Df background:

```{r echo=FALSE}
biallele.novel.byChrom <- inner_join(biallele.novel.counts %>% group_by(group, chrom) %>% summarise(novel=n()), filteredTbl.biallele %>% group_by(group, chrom) %>% summarize(total=n()), by=c("group"="group", "chrom"="chrom") ) %>% mutate(percent_novel= 100*novel/total) %>% select(c("group","chrom","total","novel","percent_novel"))

biallele.novel.byChrom %>%  mutate(percent_novel=human_readable_croncher( percent_novel)) %>%  kable(caption="Hereditarily Novel Biallaeleic INDELs, by Treatment and Chromosome")

```

In the mutant flies, the majority of the novel INDELs appear on chromosome 3 and have an allele frequency ~25%, as expected. In the control flies, there is scattering of novel INDELs with allele frequency < 25%, suggesting they are the result of alleles which are present in one of the parents but not recognized there by the variant caller.

```{r echo=FALSE}
ggplot(biallele.novel.counts) + geom_freqpoly(aes(x=mac),bins=15, color='black') + geom_freqpoly(aes(x=mac, color=chrom),bins=31) + facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Number of Sites", title="Number of Quality, Heredetarily Novel INDELs, by Minor Allele Count, Chromosome, and Treatment")

```

```{r echo=FALSE}
#ggplot(biallele.novel.counts)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=13)  + theme_clear() + labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size")
ggplot(biallele.novel.counts)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=13) + facet_wrap(~chrom, scales="free_y") + theme_clear() + labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size")
```

The subset of heredetarily novel INDELs shows a significant deletion bias in mutants but not controls, though this primarily reflects the spurious novel variants on chromosome 3. 

```{r echo=FALSE}
novel.insert_truth.Tbl <- biallele.novel.counts %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)

novel.insert_truth.Tbl <- cbind(novel.insert_truth.Tbl, map2(novel.insert_truth.Tbl$del, novel.insert_truth.Tbl$del+novel.insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(novel.insert_truth.Tbl, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel)")
```

When chromosome 3 is omitted from both control and mutants, the both the effect size and the significance deepen for mutants, but the controls still show no significant difference:


```{r echo=FALSE}
novel.insert_truth.Tbl.no3 <- biallele.novel.counts %>% filter(chrom != "chr3L") %>% filter(chrom != "chr3R") %>%  mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)

novel.insert_truth.Tbl.no3 <- cbind(novel.insert_truth.Tbl.no3, map2(novel.insert_truth.Tbl.no3$del, novel.insert_truth.Tbl.no3$del+novel.insert_truth.Tbl.no3$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(novel.insert_truth.Tbl.no3, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel) (Chromosome 3 Omitted)", digits=10)
```


#### Novel, Singleton INDELs (forward mutation)

Assuming that DSBs can occur at many places in the genome with no preference, it is expected that a site will only experience a DSB once in a small population. Additionally, since the break occurs on one chromosome, the individual with the break is expected to be heterozygous on autosomes for the resulting misrepair. Thus, the heredetarily novel INDELs were subsetted to retain only those with a minor allele count of 1. 


```{r echo=FALSE}

biallele.novel.counts.singleton <- biallele.novel.counts %>% filter(mac==1) 

full_join(biallele.novel.byChrom, biallele.novel.counts.singleton %>% group_by(group, chrom) %>% summarise(novel_singleton=n()), by=c("group"="group", "chrom"="chrom")) %>% mutate(novel_singleton=case_when(is.na(novel_singleton) ~0, TRUE ~ as.double( novel_singleton)), percent_novel_singleton =100*novel_singleton/novel)  %>%  kable(caption="Hereditarily Novel, Singleton Biallaeleic INDELs, by Treatment and Chromosome", digits=1)
```

The mutants don't appear to have a higher rate of novel INDELs than the controls (off of chr3). However, of the novel INDELs, the mutants appear to have a higher fraction which are singletons. The singleton rate for chromosome 3 in the mutants is very low, consistent with most of those INDELs being inherited from A7/Df.  

```{r echo=FALSE, warning=FALSE}
ggplot(biallele.novel.counts.singleton)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=10) + facet_wrap(~chrom, scales="free_y") + theme_clear() + scale_x_continuous(limits=c(-4,7), breaks =seq(-3,6,2))+ labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size (Novel Singletons)")

```


```{r echo=FALSE}
novel.single.insert_truth.Tbl <- biallele.novel.counts.singleton %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)
novel.single.insert_truth.Tbl <- cbind(novel.single.insert_truth.Tbl, map2(novel.single.insert_truth.Tbl$del, novel.single.insert_truth.Tbl$del + novel.single.insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(novel.single.insert_truth.Tbl, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel Singletons)")
```

The mutant flies have more novel singleton INDELs overall compared to the controls. The mutants also have a clear bias towards deletion, whereas none can be detected in the controls. This is still true when chromosome 3 is omitted:

```{r echo=FALSE}
novel.single.insert_truth.Tbl.no3 <- biallele.novel.counts.singleton %>% filter(chrom != "chr3L") %>% filter(chrom != "chr3R")  %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)
novel.single.insert_truth.Tbl.no3 <- cbind(novel.single.insert_truth.Tbl.no3, map2(novel.single.insert_truth.Tbl.no3$del, novel.single.insert_truth.Tbl.no3$del + novel.single.insert_truth.Tbl.no3$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(novel.single.insert_truth.Tbl.no3, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel Singletons) (Chromosome 3 Omitted)")
```


### Novel INDELs (back mutation)

The above variants were classified as hereditarily novel if they went undetected in the parental alignments but appeared in the offspring. In particular, the parents were required to both be homozygous for the reference allele, whereas at least one offspring held an alternative allele. It is possible that the reverse could happen: both parents are homozygous for some alternate allele, and at least one of the offspring carried a reference allele. The biological interpretation would be that the site had a fixed difference with the reference, which mutated back to the reference in an offspring. This would probably be very rare. The computational interpretation would be that the variant caller has reverted to the reference allele as a default at a site which is difficult to resolve in some individuals. Here the same examination as above is applied to these apparent back-mutations.

```{r echo=FALSE, warning=FALSE}
control.back.counts <- multicolumn_ACloader("analysis/control.vs_dm6.bwaUniq.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.back.count")
control.back.counts$group <- as.factor("control")

mutant.back.counts <- multicolumn_ACloader("analysis/mutant.vs_dm6.bwaUniq.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.back.count")
mutant.back.counts$group <- as.factor("mutant")

#biallele.back.counts <- rbind(control.back.counts, mutant.back.counts) %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) 

biallele.back.counts <- rbind(control.back.counts %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) , mutant.back.counts %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) )

biallele.back.counts.tmp <- biallele.back.counts %>% filter(`1_allele_count` >= `2_allele_count`) %>% mutate(delta_bp=len2-len1,  mac=`2_allele_count`)

biallele.back.counts <- rbind(biallele.back.counts.tmp, biallele.back.counts %>% filter(`1_allele_count` < `2_allele_count`) %>% mutate(delta_bp=len1-len2, mac=`1_allele_count`)) %>% mutate( group=`1_group`) %>%  select(-c(`2_group`))

```

There were very few such sites found in the mutants, compared to thousands in the control group:

```{r echo=FALSE}


biallele.back.byChrom <- full_join(biallele.back.counts %>% group_by(group, chrom) %>% summarise(novel=n()), filteredTbl.biallele %>% group_by(group, chrom) %>% summarize(total=n()), by=c("group"="group", "chrom"="chrom") ) %>% 
mutate(novel=case_when(is.na(novel) ~0, TRUE ~ as.double( novel))) %>% mutate(percent_novel= 100*novel/total) %>% select(c("group","chrom","total","novel","percent_novel"))



biallele.back.byChrom  %>%  kable(caption="Hereditarily Novel Biallaeleic INDELs, by Treatment and Chromosome (Back Mutations)", digits=2)

```



```{r echo=FALSE}
ggplot(biallele.back.counts) + geom_freqpoly(aes(x=mac),bins=15, color='black') + geom_freqpoly(aes(x=mac, color=chrom),bins=31) + facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Number of Sites", title="Number of Quality, Heredetarily Novel INDELs,\nby Minor Allele Count, Chromosome, and Treatment (back mutations)")

```


```{r echo=FALSE}
ggplot(biallele.back.counts)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=13)  + theme_clear() + labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size (back mutations)")
```

```{r echo=FALSE, warning=FALSE, eval=FALSE}
back.insert_truth.Tbl <- biallele.back.counts %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)
back.insert_truth.Tbl <- cbind(back.insert_truth.Tbl, map2(back.insert_truth.Tbl$del, back.insert_truth.Tbl$del+back.insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(back.insert_truth.Tbl, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel; Back Mutations)")
```


#### Novel, Singleton INDELs (back mutation)

The novel, apparent back mutations were then filtered to retain only those with a minor allele count of 1. 

```{r echo=FALSE}
biallele.back.counts.singleton <- biallele.back.counts %>% filter(mac==1) 

full_join(biallele.back.byChrom, biallele.back.counts.singleton %>% group_by(group, chrom) %>% summarise(novel_singleton=n()), by=c("group"="group", "chrom"="chrom")) %>% mutate(novel_singleton=case_when(is.na(novel_singleton) ~0, TRUE ~ as.double( novel_singleton)), percent_novel_singleton =100*novel_singleton/novel)  %>%  kable(caption="Hereditarily Novel, Singleton Biallaeleic INDELs, by Treatment and Chromosome (Back Mutations)")

```




```{r echo=FALSE}
ggplot(biallele.back.counts.singleton)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=10)  + theme_clear() + scale_x_continuous(limits=c(-4,7), breaks =seq(-3,6,2))+ labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size (Novel Singletons; Back Mutations)")

```


```{r echo=FALSE, warning=FALSE}
back.single.insert_truth.Tbl <- biallele.back.counts.singleton %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`) %>% filter(group == "control")
back.single.insert_truth.Tbl <- cbind(back.single.insert_truth.Tbl, map2(back.single.insert_truth.Tbl$del, back.single.insert_truth.Tbl$del + back.single.insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )

kable(back.single.insert_truth.Tbl, caption = "Deletion bias in mcm5 Mutants  (Hereditarily Novel Singletons; Back Mutations)")
```


The control flies have a clear excess of these apparent back mutations, many of which are listed as singeltons in the sample. These could be genuine back mutations or artefacts from the variant caller defaulting to the reference allele in some samples. Manual inspection of some of these sites suggested that they were glitchy in the effected samples; however, it is not obvious why either explanation would have such a lopsided impact on the controls but not the mutants. 



## Already-called variants

Danny Miller has already investigated these flies for likely candidates, identifying the following:

>mcm5-12, chrX:12825436, GAAA deletion

The first, chrX:12825436, was identified as a novel singleton INDEL, and manual inspection in IGV confirmed it. 

>mcm5-21, chr2R:12737873, A deletion 

The second, an A deletion at chr2R:12737873, appears in the VCF, appears to be heterozygous in two different flies (mcm5-21, and in 2 of 20 reads in mcm5-22). Additionally, although not called as such in the VCF, the Iso1 parent has this variant on 2 of 20 reads.

>mcm5-22, chr2R:8597548, T deletion

The third, a T deletion at chr2R:8597548, was identified as a novel singleton INDEL. However, although no variant was called at this site in Iso1 or w1118m, the deletion, as well as a +T insertion, appear in the filtered alignments of both at a total indel rate of 4 of 48 and 5 of 42 reads respectively (compared to 8 of 15 in mcm5-22)

>mcm5-24, chr2L:21664793, TATATA deletion

The fourth, a TATATA deletion at chr2L:21664793, appears on some reads in the unfiltered BWA alignment of both mcm5-24 and w1118m. However, these reads are missing from the filtered BWA-Uniq alignments. Moreover, the unfiltered alignments of mcm5-24 and w1118m include not only the reference sequence and a 5nt deletion, but also a 7nt deletion and a nearby 1nt insertion (AA -> ACA). In every read with a 5nt deletion, the INDEL site was flanked by two SNPs. This occurs in a repetitive region which is probably distorting the local alignment. 

# Next Steps

*	Explore PINDEL [@Ye2009] for calling larger variants
*	IMSindel? Shigemizu 2018
*	Resolve back-mutation mystery
*	*	Local realignment?
*	Include chromosome X - manage ploidy difference vs autosomes


# Bibliography

