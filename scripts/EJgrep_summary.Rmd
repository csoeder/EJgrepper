---
title: "End Joining Signatures"
author: "Charlie Soeder"
date: "3/18/2019"
output:
  pdf_document:
    toc: true
    toc_depth: 5
    number_sections: true
  html_document: default
bibliography: references.bib
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#knitr::opts_knit$set(root.dir = '/Users/csoeder/Research/PSIseq/EJgrepper/')
knitr::opts_knit$set(root.dir = '/proj/cdjones_lab/csoeder/EJgrepper/')
#knitr::opts_knit$set(root.dir=peaDubDee)

library("yaml")
library("readr")
library("knitr")
library("ggbio")
library("VennDiagram")
library("tidyverse")
library("broom")
```


```{r include=FALSE}

human_readable_croncher <- function(num_in) {
	dig <- 3
	num_out <- formatC(num_in, digits=dig, format='g') %>% as.numeric() %>% sitools::f2si()
	return(num_out)
}

bam_summary_loader <- function(filename, aligner="bwa", reference='dm6'){
	
	tmp.df <- read_delim(filename, "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
	names(tmp.df) <- c("sample","measure","value")
	
	tmp.df$sample <- as.factor(tmp.df$sample)
	tmp.df$measure <- as.factor(tmp.df$measure)
	tmp.df$aligner <- as.factor(aligner)
	tmp.df$reference <- as.factor(reference)
	
	return(tmp.df)
	
}



multicolumn_ACloader <- function(filename){
	
	max_fields<- count.fields(filename, sep = '\t') %>% max()

	tubb <- read.table(filename, header = FALSE, sep = "\t", fill = TRUE,col.names = paste0("V",seq_len(max_fields)))

	tubb.df <- tubb[1:7]

	names(tubb.df) <- c("site_id", "chrom", "pos", "var_count", "chroms_avail", "allele", "allele_count")
	tubb.df$var_num <- 1
	
	for (i in seq(8,max_fields,2)){
		tubb.df.tmp <- cbind(tubb[1:5], tubb[c(i,i+1)])
		names(tubb.df.tmp) <- c("site_id", "chrom", "pos", "var_count", "chroms_avail", "allele", "allele_count")
		tubb.df.tmp$var_num <- i/2-2
		tubb.df <- rbind(tubb.df, tubb.df.tmp %>% filter(!is.na(allele_count))  )
	}

	tubb.df <- tubb.df %>% mutate(allele_freq = allele_count/chroms_avail) %>% as_tibble()

	
	
		return( tubb.df)
}


```

# Introduction

[@McVey2008]
[@Miller2016]


# Materials, Methods, Data, Software

```{r include=FALSE}

trammel <- read_yaml("config.yaml")

```

High-thoughoutput sequences in FASTQ format were aligned to the reference genome using BWA[@Li2009] and processed with SAMtools [@Li2009a] and BEDtools [@Quinlan2010]. Variants were called from these alignments using Freebayes [@Garrison2012] and processed using VCFTools[@Danecek2011]. 


## Reference Genomes


```{r include=FALSE}
refGenomes_summary_df <- read_delim("meta/reference_genomes.summary", 
    "\t", escape_double = FALSE, col_names = FALSE, 
    trim_ws = TRUE)

names(refGenomes_summary_df) <- c("refGenome","measure","value")

```

The dm6 reference genome was used for read alignment:

```{r echo=FALSE}

refGenomes_summary_df %>% mutate( value=human_readable_croncher(value)) %>% spread(refGenome, value) %>% rename('Reference Genome:'=measure)  %>% kable(caption="Size and Consolidation of Reference Genomes")

```


## Sequenced Reads

```{r include=FALSE}
data_sets.df <- plyr::ldply(trammel$data_sets, data.frame)
data_sets.df$name <- as.factor(data_sets.df$name)
data_sets.df$paired<- as.factor(data_sets.df$paired)
data_sets.df$experimental<- as.factor(data_sets.df$experimental)
data_sets.df$subgroups<- as.factor(data_sets.df$subgroups)
data_sets.df$pedigree<- as.factor(data_sets.df$pedigree)
data_sets.df$sex<- as.factor(data_sets.df$sex)

data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,sra)) %>% distinct() 

```

Two treatments have been sequenced: a control line, and an mcm5 mutant. The data available include two parent flies per treatment as well as 28 of their male offspring: 

```{r echo=FALSE, results='asis'}
data_sets.df.sparse %>% group_by(experimental,pedigree) %>% summarise(sample_count=n()) %>% kable(caption="Number of Sequenced Samples by Treatment")
```

The samples from the mcm5 mutant cross were provided by Talia:

```{r echo=FALSE}
data_sets.df.sparse %>% filter(experimental == 'mutant') %>% select(c(name, source, pedigree, sex)) %>%  arrange(pedigree, desc(name)) %>% kable(caption="Sequenced Samples from mcm5 Mutant Cross")
```

The control samples were first published in [@Miller2016]; this cross consists of a male w1118 and a female Canton S, as well as their male offspring. 28 of the 196 sequenced offspring were selected at random and downloaded from NCBI, as were the sequenced parents:

>Males were numbered based on whether their father was homozygous w1118 or Canton-S and the number of their het- erozygous mother. For example, male cs12.3 had a Canton-S father, its mother was female number 12, and it was the third male selected for DNA extraction.

```{r echo=FALSE}


data_sets.df.sparse <- data_sets.df %>% filter(subgroups=='all') %>% select(-c(subgroups,sra)) %>% distinct() 

data_sets.df.sparse.crossMeta <- data_sets.df.sparse %>% filter(experimental == 'control') %>% select(c(name, source, pedigree, sex))  %>% mutate(tmp=name) %>% separate(tmp, sep="_", into = c("mating","offspring_id"))  %>% mutate(tmp=mating) %>% separate(tmp, sep="[sw]", into=c("A","B"))%>% mutate(tmp=mating) %>% separate(tmp, sep="[0-9]", into=c("A","C")) %>% mutate(mating=case_when(pedigree=='child' ~ mating), father_type=case_when(pedigree=='child' ~ A), mother_id=case_when(pedigree=='child' ~ B) ) %>% select(-c(A,B,C)) %>% mutate(father_type=case_when(father_type=='w' ~ "w1118",father_type=='cs' ~ "CantonS") ) 


```

```{r echo=FALSE}


data_sets.df.sparse.crossMeta %>% select(-c(mating))%>% arrange(pedigree, desc(name)) %>% kable(caption="Sequenced Samples from Control Cross")
```


```{r echo=FALSE}

data_sets.df.sparse.crossMeta %>% filter(pedigree=='child') %>% group_by(father_type, mother_id) %>% summarize(count=n()) %>% kable(caption="Number of Male Offsping Sequenced, by Cross Type and Female ID")

```


### Pre-Processing

These reads were preprocessed with FASTP [@Chen2018] for quality control and analytics. 


```{r echo=FALSE, include=FALSE}
fastp_summary <- read_delim("meta/sequenced_reads.dat", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(fastp_summary ) <- c("name","type","measure","value")
fastp_summary$name <- as.factor(fastp_summary$name)
fastp_summary$type <- as.factor(fastp_summary$type)
fastp_summary$measure <- as.factor(fastp_summary$measure)
```




```{r echo=FALSE, include=FALSE}
filtration_stats <- inner_join(fastp_summary %>%  filter(type=="prefiltered" | type == 'postfiltered'), data_sets.df.sparse, by=c("name"="name"))
filtration_stats$type <- factor(filtration_stats$type, levels=c("prefiltered", "postfiltered"))
```


Starting FASTQ files contained a total of  $`r sum( filtration_stats %>% filter(type =='prefiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$ reads; after QC, this dropped to $`r sum( filtration_stats %>% filter(type =='postfiltered') %>%  filter(measure=='total_reads') %>% select(value) ) %>% human_readable_croncher() `$. 



```{r echo=FALSE}
pre_post_counts <- filtration_stats %>% filter(measure=='total_reads') %>%  group_by(type)  %>%  summarise(minimum = min(value), average=mean(value) , maximum = max(value)) 
retention_percent <- filtration_stats %>% filter(measure=='total_reads') %>% select(c(name,type,value)) %>%  spread(type,value) %>% mutate(retention=100*postfiltered/prefiltered) %>%  summarise(type='percent retention', minimum = min(retention), average=mean(retention) , maximum = max(retention))
```

```{r echo=FALSE}
rbind(pre_post_counts, retention_percent) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average) , maximum = human_readable_croncher(maximum)) %>% kable(caption="Read Count and Percent Retention")
```

Filtration also increased the read quality, as seen in the increase in the fraction of reads with an average quality score > 30:

```{r echo=FALSE}
ggplot(filtration_stats %>% filter(measure == "q30_rate")) + geom_line(aes(group=name, x=type,y=100*value)) +  geom_point(aes(x=type, y = 100*value, color=experimental)) + labs(title = "Percent of Reads with a mean QUAL > 30", y="Percent QUAL > 30", x="") + theme_clear()

```



Duplicate reads were also detected; these will be filtered during alignment:

```{r echo=FALSE, include=FALSE}
dupe_stats <- inner_join(fastp_summary %>% filter(type=='duplication' & measure =='rate') %>%  mutate(percent=value*100) %>% select(c(name,percent)), data_sets.df.sparse, by=c("name"="name"))
```

```{r echo=FALSE}
dupe_stats %>%  summarise(minimum = min(percent), average=mean(percent), median=median(percent) , maximum = max(percent)) %>% kable(caption="Percentage Duplication",digits=1)
```

```{r echo=FALSE}
ggplot(dupe_stats) + geom_histogram(aes(x=percent), bins=15) + labs(title="Duplication Histogram", x="Read Duplication Rate (FASTP estimate)", y="Number Samples") + theme_clear()
```



## Mapped Reads

Reads were first mapped to the reference genome using the BWA SAMPE/SE algorithm. Then, the alignment file was filtered for uniqueness (ie, a read must be aligned optimally with no alternative or runner-up hits, "XT:A:U.*X0:i:1.*X1:i:0"), mapping/sequencing quality ("-q 20 -F 0x0100 -F 0x0200 -F 0x0300 -F 0x04"), and deduplication. 



```{r echo=FALSE, include=FALSE}

vs_dm6.bwa <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwa.summary",aligner="bwa", reference="dm6")
vs_dm6.bwaUniq <- bam_summary_loader(filename = "meta/alignments.vs_dm6.bwaUniq.summary",aligner="bwaUniq", reference="dm6")

all_alignments <- rbind(vs_dm6.bwa, vs_dm6.bwaUniq)
```



### Read & Alignment Quality



```{r echo=FALSE}
readcount_process <- all_alignments %>%  filter( (measure=='total_read_count' & aligner=="bwa") | measure == 'total_mapped_count' ) %>% mutate(measure=ifelse(aligner=="bwaUniq", "filtered_mapped_count", ifelse(measure=="total_read_count","total_read_count","total_mapped_count"))) 
readcount_process$measure <- factor(readcount_process$measure, levels = c('total_read_count','total_mapped_count','filtered_mapped_count'))
```

The fraction of reads retained at each filtration step:


```{r echo=FALSE}
#ggplot(readcount_process) +
ggplot(inner_join(readcount_process, data_sets.df.sparse, by=c("sample"="name"))) + geom_line(aes(group=sample, x=measure,y=value)) + geom_point(aes(x=measure, y=value, group=sample,color=experimental, shape=pedigree))  + labs(title="Read Counts by Processing Step: Unmapped, Mapped, Filtered", x="", y="Number Reads" ) + theme_clear() + theme(axis.text.x = element_text(angle = -45, hjust = 0), legend.position='none' ) 

```

```{r echo=FALSE}

readcount_process.spread <- readcount_process %>% select(-c(aligner)) %>%  spread(measure, value) %>%  mutate(mapping_retention=total_mapped_count/total_read_count, filter_retention = filtered_mapped_count/total_mapped_count)



readcount_process.spread.gathered <- readcount_process.spread%>% gather(total_read_count:filtered_mapped_count, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(value), average=mean(value), median = median(value), maximum = max(value)) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average), median = human_readable_croncher(median), maximum = human_readable_croncher(maximum))

#readcount_process.spread.gathered$measure <- factor(readcount_process.spread.gathered$measure, levels=c("total_read_count", "total_mapped_count","filtered_mapped_count"))

readcount_process.spread.gathered %>% kable(caption="Read Counts During Alignment & Filtration")

```


```{r echo=FALSE}
readcount_process.spread %>% gather(mapping_retention:filter_retention, key="measure", value="value") %>%  group_by(measure) %>% summarise(minimum = min(100*value), average=mean(100*value), median = median(100*value), maximum = max(100*value)) %>% mutate(minimum = human_readable_croncher(minimum), average=human_readable_croncher(average), median = human_readable_croncher(median), maximum = human_readable_croncher(maximum)) %>%  kable(caption="Percentage of Reads Retained at Each Step",digits=1)

```



### Depth & Breadth of Coverage


```{r echo=FALSE, include=FALSE}

before_After.cov <- inner_join( vs_dm6.bwa %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), vs_dm6.bwaUniq %>%  filter(measure=='avg_depth' | measure == 'total_breadth') %>% select(-c(aligner)) %>% spread(measure, value), by='sample', suffix=c(".before",".after") ) %>%  mutate(depth_retention = avg_depth.after/avg_depth.before, breadth_retention=total_breadth.after/total_breadth.before)


before_After.cov.gathered.meta <- inner_join(before_After.cov %>%  gather(avg_depth.before:breadth_retention, key="measure", value="value") , data_sets.df.sparse, by=c("sample"="name") ) 


```


Depth of coverage, ie, the genome-wide average number of mapped reads per base pair:


```{r echo=FALSE}

depth.process <- all_alignments  %>%  filter(measure=='avg_depth' )%>% spread(aligner, value) %>%  mutate(depth_retention = 100*bwaUniq/bwa) %>% rename( "before" = bwa,  "after" = bwaUniq)

covstats.dpth <- depth.process %>% summarise(step="pre-filtration depth",minimum = min(before), average=mean(before), median = median(before), maximum = max(before))

covstats.dpth <- rbind(covstats.dpth, depth.process %>% summarise(step="post-filtration depth",minimum = min(after), average=mean(after), median = median(after), maximum = max(after)))

covstats.dpth <- rbind(covstats.dpth, depth.process  %>% summarise(step="depth retention percent",minimum = min(depth_retention), average=mean(depth_retention), median = median(depth_retention), maximum = max(depth_retention)))

covstats.dpth %>% kable(caption="Depth of Coverage Statistics for Raw and Filtered Alignments", digits=1 )
```


```{r echo=FALSE}
depth.process <- inner_join(depth.process, data_sets.df.sparse %>% select(-c("paired", "path", "readsfile1", "readsfile2")), by=c("sample"="name"))

ggplot(depth.process %>%  select(-c(depth_retention,measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after"))))  +geom_line(aes(group=sample, x=measure,y=value))+ geom_point(aes(group=sample, x=measure,y=value, shape=experimental, color=pedigree)) + geom_text(data=depth.process %>%  select(-c(depth_retention,measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after"))) %>% filter(value < 25), aes(as.factor("after"),value,label=sample)) + theme_clear()   +  labs(title="Depth Of Coverage for Raw and Filtered Alignments", x="", y="Reads Per BP, Genome-Wide" ) 

```


```{r echo=FALSE, include=FALSE}
breadth.process <- all_alignments %>%  filter(measure=='total_breadth' ) %>% spread(aligner, value) %>%  mutate(breadth_retention = 100*bwaUniq/bwa) %>% rename( "before" = bwa, "after" = bwaUniq)

covstats.brdth <- breadth.process %>% summarise(step="pre-filtration breadth",minimum = 100*min(before), average=100*mean(before), median = 100*median(before), maximum = 100*max(before))

covstats.brdth <- rbind(covstats.brdth, breadth.process %>% summarise(step="post-filtration breadth",minimum = 100*min(after), average=100*mean(after), median = 100*median(after), maximum = 100*max(after)))

covstats.brdth <- rbind(covstats.brdth, breadth.process  %>% summarise(step="breadth retention percent",minimum = min(breadth_retention), average=mean(breadth_retention), median = median(breadth_retention), maximum = max(breadth_retention)))

covstats.brdth %>% kable(caption="Breadth of Coverage Statistics for Raw and Filtered Alignments", digits=1 )

```


Breadth of coverage, ie, the percentage of the genome covered by at least one read:

```{r echo=FALSE}

breadth.process <- inner_join(breadth.process, data_sets.df.sparse %>% select(-c("paired", "path", "readsfile1", "readsfile2")), by=c("sample"="name"))



ggplot(breadth.process %>%  select(-c(breadth_retention, measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after")), value=100*value) ) + geom_point(aes(group=sample, x=measure,y=value, shape=experimental, color=pedigree)) + geom_line(aes(group=sample, x=measure,y=value)) + theme_clear()  + labs(title="Breadth Of Coverage for Raw and Filtered Alignments", x="", y="Percentage of Reference Genome Mapped To" )
#  + geom_text(data=breadth.process %>%  select(-c(breadth_retention, measure)) %>%  gather(before:after, key=measure, value=value) %>% mutate(measure=factor(measure, levels=c("before","after")), value=100*value), aes(as.factor("after"),value,label=sample, x=)) 
```


## Called Variants

The BWA-Uniq alignments for the control and mutant flies were independently used to call variants in VCF format via Freebayes [@Garrison2012] using standard filters. 


```{r echo=FALSE, include=FALSE}

allGroups.vs_dm6.calledVariants.summary <- read_delim("meta/allGroups.vs_dm6.bwaUniq.calledVariants.summary", "\t", escape_double = FALSE, col_names = FALSE, trim_ws = TRUE)
names(allGroups.vs_dm6.calledVariants.summary) <- c("group", "aligner", "variant_type", "count")
allGroups.vs_dm6.calledVariants.summary$aligner <- as.factor(allGroups.vs_dm6.calledVariants.summary$aligner)
allGroups.vs_dm6.calledVariants.summary$variant_type <- as.factor(allGroups.vs_dm6.calledVariants.summary$variant_type)

reference_genomes_summaryStats.sprud <- refGenomes_summary_df %>%  spread(measure,value) %>%  select(c(-number_contigs)) 

allGroups.vs_dm6.calledVariants.summary.sprud <- allGroups.vs_dm6.calledVariants.summary %>% spread(variant_type, count) %>%  transmute( aligner=aligner, group = group, INDELs = total_indel_count, SNPs = total_snp_count) 

allGroups.vs_dm6.calledVariants.summary.sprud$total_bp <- reference_genomes_summaryStats.sprud$number_bases


allGroups.vs_dm6.calledVariants.summary.sprud %>%  transmute( aligner=aligner, INDELs = INDELs, INDEL_per_kb=1000*INDELs/total_bp, SNPs = SNPs, SNP_per_kb=1000*SNPs/total_bp) %>% mutate(INDELs=human_readable_croncher(SNPs), INDELs=human_readable_croncher(SNPs) ) %>%  kable(caption="Variant Counts and Frequency by Type and Group", digits=1 )
```


For each group VCF, 30 samples from the group called jointly. However, not all sites were called in all samples (eg, due to coverage differences). The sites had the following group-wide call rate:



```{r echo=FALSE, include=FALSE}
mutant.calledVariants.bwaUniq.lmiss <- read_delim("meta/VCFs/mutant.vs_dm6.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
mutant.calledVariants.bwaUniq.lmiss$group <- "mutant"

control.calledVariants.bwaUniq.lmiss <- read_delim("meta/VCFs/control.vs_dm6.bwaUniq.summary.lmiss", "\t", escape_double = FALSE, trim_ws = TRUE)
control.calledVariants.bwaUniq.lmiss$group <- "control"

allGroups.calledVariants.lmiss <- rbind(control.calledVariants.bwaUniq.lmiss, mutant.calledVariants.bwaUniq.lmiss) %>% select(c(group, N_MISS, N_DATA)) %>%  mutate(group=as.factor(group), N_PRES=floor(N_DATA/2))

```



```{r echo=FALSE}

nsamps <- max(allGroups.calledVariants.lmiss$N_PRES)

ggplot(allGroups.calledVariants.lmiss) + geom_freqpoly(aes(x=N_PRES, group=group, color=group), bins=nsamps) + scale_x_continuous(name ="Number Samples",limits=c(1,nsamps), breaks =seq(1,nsamps,1)) + theme_clear() + labs(title="Histogram of Variant Site Count,\n by Number of Samples Called At Site", y="Number of Sites")

```


The fraction of jointly called SNPs which are individually callable:

```{r echo=FALSE, include=FALSE}


mutant.calledVariants.imiss <- read_delim("meta/VCFs/mutant.vs_dm6.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
mutant.calledVariants.imiss$group <- "mutant"

control.calledVariants.imiss <- read_delim("meta/VCFs/control.vs_dm6.bwaUniq.summary.imiss", "\t", escape_double = FALSE, trim_ws = TRUE)
control.calledVariants.imiss$group <- "control"


allGroups.calledVariants.imiss <- rbind(control.calledVariants.imiss, mutant.calledVariants.imiss)  %>%  mutate(name=as.factor(INDV), group=as.factor(group), N_PRES=N_DATA-N_MISS) %>% select(c( name, N_MISS, N_PRES, F_MISS,group))

```

```{r echo=FALSE, include=FALSE}


all_samples.imiss.augmented <- inner_join(all_samples.imiss, all_alignments %>%  filter(measure=='total_breadth') %>% select(c(sample,aligner,value)) %>% rename(breadth=value) %>% mutate(breadth = 100*breadth), by=c("name"="sample", "aligner"="aligner"))

all_samples.imiss.augmented <-inner_join(all_samples.imiss.augmented, all_alignments %>%  filter(measure=='avg_depth') %>% select(c(sample,aligner,value)) %>% rename(depth=value), by=c("name"="sample", "aligner"="aligner"))

all_samples.imiss.augmented <- all_samples.imiss.augmented %>%  gather(breadth:depth, key="measure", value="value")

```

```{r echo=FALSE}
ggplot(allGroups.imiss.augmented) + geom_point(aes(x= value, y=1-F_MISS, color=group, shape=group)) + facet_grid(.~measure, scales="free_x") + theme_clear() + labs(x="", y="Fraction of Sites Callable", title="Jointly Called Variants Callable per Sample,\n by Breadth and Depth of Coverage")

```

## Variant Analysis

```{r echo=FALSE}

filteredTbl.cntrl <- multicolumn_ACloader("analysis/control.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.out") 
filteredTbl.cntrl$group <- as.factor("control")
filteredTbl.mut <- multicolumn_ACloader("analysis/mutant.alleleCounts.simpleIndels.dpthFilt.biallelic.universal.out") 
filteredTbl.mut$group <- as.factor("mutant")

filteredTbl.biallele <- rbind(filteredTbl.cntrl, filteredTbl.mut) %>% gather(variable, value, -(site_id:chroms_avail), -var_num) %>% unite(temp, var_num, variable) %>%  spread(temp, value) %>% mutate(len1 = nchar(`1_allele`),len2 = nchar(`2_allele`), `1_allele_count`=as.numeric(`1_allele_count`), `2_allele_count`=as.numeric(`2_allele_count`), `1_allele_freq`=as.numeric(`1_allele_freq`), `2_allele_freq`=as.numeric(`2_allele_freq`)) 


filteredTbl.biallele.tmp <- filteredTbl.biallele %>% filter(`1_allele_count` >= `2_allele_count`) %>% mutate(delta_bp=len2-len1,  mac=`2_allele_count`)

filteredTbl.biallele <- rbind(filteredTbl.biallele.tmp, filteredTbl.biallele %>% filter(`1_allele_count` < `2_allele_count`) %>% mutate(delta_bp=len1-len2, mac=`1_allele_count`)) %>% mutate( group=`1_group`) %>%  select(-c(`2_group`))
```



To search for traces of end-joining, the BWA-Uniq derived variants were further filtered, requiring a depth of 10 reads at the site for all flies sequenced: the per-site probability of sampling the same chromosome 10 times is < 0.1% given a fair draw, but this threshold is lower than the minimum average depth of coverage among the samples. Although it is possible that the join could occur near an already polymorphic site, or might manifest as a complex variant rather than a simple insertion/deletion, for the time being only proper biallelic indels were retained. Finally, only the consolidated autosomes were considered, and only sites which could be called in all 30 sequenced flies. 

Between the two treatments, this gave a total of $`r filteredTbl.biallele %>% nrow()  `$ sites: 

```{r echo=FALSE}
filteredTbl.biallele %>% group_by(chrom,group) %>% summarize(count=n()) %>% spread(group,count) %>%  kable(caption="Quality Biallaeleic INDELs per Chromosome")
```

For these sites, minor and major alleles were assigned on the basis of which of the two variants had a smaller or larger allele count, respectively. INDEL type & size were determined relative to the major allele. 

_parental variant removal_




# Results

## INDEL Size & Frequency


```{r echo=FALSE}
ggplot(filteredTbl.biallele %>%  group_by(mac, delta_bp,group) %>% summarise(count=n())) + geom_tile(aes(x=mac,y=delta_bp, fill=count)) +facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Nucleotides Inserted or Deleted", title="Heatmap of INDEL Count, by Frequency and Size") + scale_fill_gradient(name = "Site Count", trans = "log", breaks = c(1,10,100,1000), labels = c(1,10,100,1000)) + theme( panel.background = element_rect(fill = "black", colour = "black"))
```


Since DSB is likely to create unique variants in the population, allele frequency is an important property to filter on. To get an idea of the expected allele frequency distribution, consider that for a given variable site, a diploid parent may be homozygous reference (a/a), homozygous alternate (A/A), or heterozygous (a/A). Thus, there are five relevant pairings of genotype: AA x AA, aa x aA, aa x AA, aA x AA, and aA x aA. (aa x aa corresponds to the case in which both parents have the reference allele, and the expectation would be the offspring would as well.) Under random assortment, the aa x aA and aA x AA crosses give a minor allele frequency of 1/4 and the aa x AA and aA x aA crosses give a minor allele frequency of 1/2. Finally, the AA x AA cross corresponds to the case where the parents are fixed for an alternate allele, and thus the offpsring would be expected to be fixed as well; the minor allele frequency would thus be zero. So, given sample of 30 diploid flies, the expected distribution of minor allele counts would be peaks centered on 0, 15, and 30. 



```{r echo=FALSE}
ggplot(filteredTbl.biallele) + geom_freqpoly(aes(x=mac),bins=15, color='black') + geom_freqpoly(aes(x=mac, color=chrom),bins=31) + facet_grid(group~.) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Number of Sites", title="Number of Quality INDELs, by Minor Allele Count and Chromosome")
mac0 <-filteredTbl.biallele %>% filter(mac == 0) %>% nrow() 
mac1 <-filteredTbl.biallele %>% filter(mac == 1) %>% nrow() 
mac2 <-filteredTbl.biallele %>% filter(mac == 2) %>% nrow() 
macTot <- filteredTbl.biallele %>%  nrow()
rareRefs <- filteredTbl.biallele %>%  filter(`1_allele_count`<3) %>% filter(`1_allele_count`>0) %>% group_by(mac) %>% summarize(count=n()) %>% select(count) %>% sum()
```

revisit this:

_At first glance, the distribution is as expected (black line above), but closer inspection reveals some anomalies. First, the peak near zero is not driven by fixed differences with the reference; there are in fact suprisingly few such fixed INDELs ($`r mac0 `$ out of $`r macTot `$ ). Instead, it is almost entirely sites with a variant on one ($`r mac1 `$) or two ($`r mac2 `$) chromosomes across all samples. (All but $`r rareRefs `$ were alternate alleles, ie, disagreements with the reference genome.)_
(It looks like there are many more fixed difference vs dm6 in the control flies???)

_Under random assortment, there would be no reason to expect autosomes to have different allele-frequency distributions. However, this isn't the case when the variant sites are grouped by chromsome: the arms of chromosome 3 are enriched in sites with allele frequency ~50% and depleted of the very rare alleles. Conversely, the arms of chromsome 2 are depleted of the medium-frequency alleles and enriched for the rare ones. It also appears that the arms of chromosome 3 are split around the expected peak at MAC=15, into two smaller groups of peaks near MAC~10 and MAC~20. These would correspond to ratios of ~1/6 and 2/6._ 


```{r echo=FALSE}
ggplot(filteredTbl.biallele)  + geom_freqpoly(aes(x=delta_bp, color=group), bins=13)  + theme_clear() + labs(x="Nucleotides Inserted/Deleted", y="Number of Sites", title="INDEL Count by Size")
```


INDEL size ranged from 6bp deletions to 6bp insertions, with a small but significant bias towards deletion:


```{r echo=FALSE}
insert_truth.Tbl <- filteredTbl.biallele %>% mutate(ins=delta_bp>0) %>% group_by(ins,group) %>% summarise(count=n()) %>% spread(ins,count)%>% rename(ins=`TRUE`, del=`FALSE`)
insert_truth.Tbl <- cbind(insert_truth.Tbl, map2(insert_truth.Tbl$del, insert_truth.Tbl$del+insert_truth.Tbl$ins, prop.test) %>% map_df(glance) %>% select(c("estimate","p.value")) %>% rename(fraction_del=estimate) )
 
kable(insert_truth.Tbl, caption = "Deletion bias in mcm5 Mutants")

```

revisit this
_(A similar result holds if the count by type is scaled by the change in length, for a ratio of bp removed to total bp change)._

When constrained to a single MAC value, the basic form of the distribution stays the same but the degree of mutational bias varies, with the highest-MAC variants even having a significant excess of insertions. 


```{r echo=FALSE}

ggplot(filteredTbl.biallele %>% mutate(ins=delta_bp>0) %>% group_by(mac,ins,group) %>% summarise(count=n()) %>% spread(ins,count) %>% rename(ins=`TRUE`, del=`FALSE`) %>%  mutate(rat = prop.test(del, ins+del)$estimate, pea=prop.test(del, ins+del)$p.value, peaAdj = p.adjust(pea, method='bonferroni'))) + geom_line(aes(x=mac, y=rat, linetype=group), alpha=0.25) + geom_point(aes(x=mac, y=rat, color=group, alpha=peaAdj<0.05)) + geom_hline(yintercept=0.5, linetype='dotted', color='blue', size=1) + theme_clear() + labs(x="Minor Allele Count (chromosomes)", y="Proportion of Deletions", title="Results of Proportion Test for Deletions, by Minor Allele Count", alpha = "significance\n(adjusted)")

```


### Novel Singletons

Of particular interest in the context of DSB repair are INDELs which appear in exactly one sample as a heterozygote, ie, with an allele count of 1. These make up $`r filteredTbl.biallele %>% filter(mac==1) %>% nrow() `$ of $`r filteredTbl.biallele %>% nrow() `$ total sites  ($`r human_readable_croncher(100*(filteredTbl.biallele %>% filter(mac==1) %>% nrow())/(filteredTbl.biallele %>% nrow()))`$ ) %. As previously discussed, they disproportionately appear on the arms of chromosome 2:


  
  
  
```{r echo=FALSE}
filteredTbl.biallele %>% filter(mac==1) %>% group_by(chrom) %>% summarise(count=n())  %>% kable(caption="Distribution of Singleton INDELs Across Autosomes")
```

## Already-called variants

Danny Miller has already investigated these flies for likely candidates, identifying the following:

>mcm5-12, chrX:12825436, GAAA deletion
>mcm5-21, chr2R:12737873, A deletion 
>mcm5-22, chr2R:8597548, T deletion
>mcm5-24, chr2L:21664793, TATATA deletion



The first, chrX:12825436, appears in the VCF but is called as a homozygote (both BWA an BWA-Uniq alignments agree here!)

The second, an A deletion at chr2R:12737873, appears in the VCF, appears to be heterozygous in two different flies (mcm5-21,mcm5-22). Also, there are two insertions (+A, +AA) at this site as well in the samples. (DfMcm5 and Mcm5-A7, respectively).

The third, a T deletion at chr2R:8597548, appears in the VCF, heterozygous in a single individual. This is another site with 4 different insertion-deletion alleles called. 

The fourth, a TATATA deletion at chr2L:21664793, doesn't appear in this VCF (filtered for depth, variants simplified, complex variants removed, indels only). However, it is picked up in the unfiltered BWA-Uniq VCF as a complex variant: TAC -> CAT. It is called as heterozygous in five individuals: mcm5-04,mcm5-03,mcm5-13,mcm5-18	mcm5-27,mcm5-19. mcm-24, instead of the TATATA deletion, is called as homozygous for the reference (the unfiltered BWA alignment for mcm5-24 has some 5 and 7bp indels but this still gets resolved as an MNP in the BWA-derived VCF. These reads are gone in BWA-Uniq.). The alignments give weak support for the existence of the TAC->CAT variant: the variant sites are there in the reads, but coverage is pretty low and the variation always seems to occur near the ends of the reads. In some cases the complex variant has been imputed from a single SNP near the end of a read. 

# Next Steps

*	Explore PINDEL [@Ye2009] for calling larger variants
*	Incorporate Talia's data


# Bibliography

